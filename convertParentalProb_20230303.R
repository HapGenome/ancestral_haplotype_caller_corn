## Author: Tao Zuo
## Breeding Genome Analytics
#### 2023/03/03 ####
# the LSH and ParHap versions are 2023/03/03


# This project is set to generate Ancestral Haplotypes (AncHap);
# Major Inputs: 
#1. Parental haplotypes
#2. Pedigree information: direct parents and included ancestors from Parental Haplotype (ParHap)
#3. Long shared haplotypes
#4. Info for Heterozygous regions 
#5. Genetic Map
#6. ParHap related Bin Map

# Major Outputs:
#1. Ancestral Haplotypes
#2. Probability associated with each Ancestral Haplotype


# Major steps:
# Step 1: Get access to recent LSH data 
# LSH data could be pulled from CSW and its summary info is usually saved at S3 bucket 
# Step 2: Collect ParHap Data
# ParHap data is generated by Danny and usually saved/shared as Domino dataset
# Step 3: Correct parental info and line names
# lines with specific character in the name are sometimes called wrong in the ParHap 
# Step 4: Pull LSH data 
# parent-offspring LSH: used to filling divergent descent
# parent-parent LSH: used to collapse HetBD (heterozygous by Descent) & Homozygous by State;
# Step 5: Determine the order of running Ancestral Haplotype Caller (layer)
# To improve the running efficiency, it would be better to run layers by layers (eg. parental lines first)
# Step 6: Collect other inputs required for running Ancestral Haplotype Caller
# Genetic map; Bin Map; Heterozygous info; etc;
# Step 7: Run Ancestral Haplotype Caller
# 


#### Requirments ####
# R Libraries (install as needed)
library(aws.s3)
library(tidyverse)
library(parallel)
library(MASS)
library(foreach)
library(doParallel)

# Access to S3 bucket (genome-analytics)
# Access to CSW
# Access to shared data (ParHap)

# setup folders
haploVersion = "20230303"
pbhFolder <- paste0("/mnt/ancestralHaploCaller_",haploVersion)
dataFolder <- paste0(pbhFolder,"/data/")
resultsFolder <- paste0(pbhFolder,"/results/")
tmpDataFolder <- paste0(pbhFolder,"/tmpData/")

dir.create(pbhFolder)
system(paste("mkdir",dataFolder,resultsFolder,tmpDataFolder))
system(paste("mkdir", paste0(rep(resultsFolder,4),
                             c("astHaploData","astHaploProb","parentalHaploData","parentalHaploProb"),collapse = " ")))


#### pre-settings ####
# load hetRegionData, genetic map, bin map

#1. load a bin index map; usually can find from Danny's haploProb data
generateNewPredMap <- function(){
  #myNewCsvRaw = get_object("tzuo/Project/AncestorHaplotypes/newAncestorHaploCaller/supportingData/predictionMap_v6.csv", bucket="breeding-scratch-space")
  predictionMap <- read.csv("/mnt/data/predictionMap_v6.csv",stringsAsFactors = FALSE)
  row.names(predictionMap) <- predictionMap$markerName
  newPredictionMap <- as.character()
  for(chr in 1:10){
    tmp <- predictionMap %>% filter(genMapChr == chr)
    tmpDf <- tmp[1:(nrow(tmp)-1),]
    newPredictionMap <- rbind(newPredictionMap,tmpDf)
  }
  row.names(newPredictionMap) <- newPredictionMap$markerName
  newPredictionMap$index <- 1:nrow(newPredictionMap)
  return(newPredictionMap)
}

newPredictionMap <- generateNewPredMap()

chrStartEnd <- newPredictionMap %>% group_by(genMapChr) %>% summarise(st = min(index),ed = max(index))

#2. Genetic map
genMap <- MONv6 <- read.csv("/mnt/data/Maize__MONv6_0__Map_2.txt",stringsAsFactors = F)

genMap$predictMap_index <- NA
for(i in 1:nrow(genMap)){
  chr <- genMap$genMapChr[i]
  pos <- round(genMap$genMapPos[i],1)
  genMap$predictMap_index[i] <- subset(newPredictionMap,genMapChr == chr & genMapPos == pos)$index
}


#3. read the het regions for each line

getHetRegionData <- function(genMap,dataFolder){
  #s3://bay-breeding-np-genome-analytics-635590664227/applications/longSharedHaplotypes/Maize/data/Maize__MONv6_0__LshFpGenos.HetRegions.gz
  data <- read.csv(gzfile(paste0(dataFolder,"Maize__MONv6_0__LshFpGenos.HetRegions.gz")), sep = "\t",check.names = F,header=F,stringsAsFactors = F)
  data$start_index <- genMap$predictMap_index[data$V6]
  data$end_index <- genMap$predictMap_index[data$V7]
  return(data)
}

hetRegionData <- getHetRegionData(genMap,dataFolder)



#### 1. collect and correct line names ####

# all LSH lines in the version
save_object("applications/longSharedHaplotypes/Maize/data/Maize__MONv6_0__LshFpGenos.HetSoft.index",
            bucket = "bay-breeding-np-genome-analytics-635590664227",
            file = paste0("/mnt/ancestralHaploCaller_",haploVersion,"/tmpData/Maize__MONv6_0__LshFpGenos.HetSoft.index")) 

allLshLineData  <- read.delim(paste0("/mnt/ancestralHaploCaller_",haploVersion,"/tmpData/Maize__MONv6_0__LshFpGenos.HetSoft.index"),header=F,stringsAsFactors = F)

# get the maxProb information and line names (parental Haplotypes)
system(paste0("ls /domino/datasets/FP_Parental_Haplotypes/",haploVersion,"/maxHaploProbs/ > /mnt/ancestralHaploCaller_",haploVersion,"/data/lineNames_maxProb.txt"))
maxProbLineData <- read.table(paste0("/mnt/ancestralHaploCaller_",haploVersion,"/data/lineNames_maxProb.txt"))
AaaSOrigins = allHaploLines <- unique(unlist(strsplit(as.character(maxProbLineData$V1),".csv")))


# change lineNames; Lines have different names between LSH data nd parental haplotype data
# 5 lines still missed in the LSH dataset after changing names; These 5 lines are ignored

linesMissNames <- AaaSOrigins[!AaaSOrigins %in% allLshLineData$V1]
if(length(linesMissNames) > 0){
  names(linesMissNames) <- linesMissNames %>%  str_replace_all("%40","@") %>%  str_replace_all("%3A",":") %>% str_replace_all("%28","(") %>% str_replace_all("%29",")") %>% 
    str_replace_all("%2C",",") %>% str_replace_all("%3C","<") %>% str_replace_all("%3E",">") %>% str_replace_all("%5E","^") %>% 
    str_replace_all("%26","&") %>% str_replace_all("%23","#")
}

table(names(linesMissNames) %in% allLshLineData$V1)

linesRemoved <- linesMissNames[which(!names(linesMissNames) %in% allLshLineData$V1)]
linesRemoved

linesMissNames <- linesMissNames[names(linesMissNames) %in% allLshLineData$V1]


#### 2. correct all parents ####
# #In the new calls, Danny generated the direct parent and incluededAncestor

metaDataPathDomino = paste0("/domino/datasets/FP_Parental_Haplotypes/",haploVersion,"/metaData/")
allMetaFiles = list.files(metaDataPathDomino)

pullPedigreeInfor = function(metaDataPathDomino,allMetaFiles){
  numCores <- detectCores()
  registerDoParallel(numCores)
  
  newPrtData = data.frame()
  newPrtData <- foreach(count = 1:length(allMetaFiles),.combine=rbind) %dopar% {
    tmpFile = paste0(metaDataPathDomino,allMetaFiles[count])
    if(file.exists(tmpFile)){
      tmp = read.csv(tmpFile)
      tmp = tmp %>% dplyr::select(pedigree, parents, includedAncestors) %>% mutate_all(as.character)
      newPrtData = bind_rows(newPrtData,tmp)
    }
  }
  row.names(newPrtData) = newPrtData$pedigree
  
  saveRDS(newPrtData,paste0(dataFolder,"parental_haplotype_parents.rds"))
  return(newPrtData)
}
  
newPrtData = pullPedigreeInfor(metaDataPathDomino,allMetaFiles)
newPrtData <- newPrtData[newPrtData$pedigree %in% allLshLineData$V1,]


# get all the ancestors 
allAncestors <- unique(unlist(sapply(newPrtData$includedAncestors,function(x){unlist(strsplit(x,";"))})))
missedAncestors <- allAncestors[!allAncestors %in% allLshLineData$V1]
# LH244-ZMS21558275-GSF4 not present in the LSH data
missedAncestorsNames <- missedAncestors
names(missedAncestors) <- missedAncestorsNames

# remove lines with any of the missed ancestors
table(str_detect(newPrtData$includedAncestors,paste(missedAncestors[!missedAncestors %in% allLshLineData$V1],collapse ="|")))
# FALSE  TRUE 
# 68400    34 

newPrtData <- newPrtData[!str_detect(newPrtData$includedAncestors,paste(missedAncestors[!missedAncestors %in% allLshLineData$V1],collapse ="|")),]
#write.csv(newPrtData,paste0(dataFolder,"parental_haplotype_parents_updatedAncestors.csv")) 


#### 3. generate LSH data ####

allAsts <- unique(unlist(sapply(newPrtData$includedAncestors,function(x){unlist(strsplit(x,";"))})))


numCores <- detectCores()
numCores
registerDoParallel(numCores)

cswQuery = function(project, query){
  bqResult = bigrquery::bq_project_query(project, query)
  bqData = bigrquery::bq_table_download(bqResult,page_size=20000)
  return(bqData)
}

library(bigrquery)
bq_auth(use_oob = TRUE)


res <- foreach(count = 1:length(allAsts),.combine=rbind) %dopar% {
  prt <- allAsts[count]
  if(!file.exists(paste0(tmpDataFolder,"tmpLshData/lshData_",prt,".rds"))){
    index <- which(str_detect(newPrtData$includedAncestors, paste0("^",prt,"$|^",prt,";|",";",prt,";|",prt,"$") ))
    lines <- newPrtData$pedigree[index]
    
    # newest vesion as  Dec 13, 2022, 6:13:55 PM UTC-5 
    query = paste0("select line1, line2, start_index, end_index from `bcs-breeding-datasets.breeding_genomics_raw.long_shared_haplotypes_maize` as lsh where lsh.line1='",
                   prt,"'"," and lsh.line2 in  (%s)")
    query <- sprintf(query,toString(sprintf("'%s'",lines)))
    lsh <- as.data.frame(cswQuery("bcs-breeding-datasets", query))
    saveRDS(lsh,paste0(tmpDataFolder,"tmpLshData/lshData_",prt,".rds"))
  }
  
}



# combine into a single file
lshData <- data.frame()
for(prt in allAsts){
  lsh <- readRDS(paste0(tmpDataFolder,"tmpLshData/lshData_",prt,".rds"))
  lshData <- bind_rows(lshData,lsh)
}

# remove duplicates
lshData$order <- lshData$line1 < lshData$line2
lshData2 <- lshData %>% filter(order == "TRUE")
lshData3 <- lshData %>% filter(order == "FALSE")
colnames(lshData3)[1:2] <- c("line2","line1")
lshData3 <- lshData3[,c(2,1,3,4)]
lshData <- bind_rows(lshData2[,1:4],lshData3)
lshData <- unique(lshData)

lshData <- lshData %>%
  mutate(start_index_map = genMap$predictMap_index[lshData$start_index],
         end_index_map = genMap$predictMap_index[lshData$end_index])

#saveRDS(lshData,paste0(dataFolder,"lshData_AstAndProg.rds"))
lshData = readRDS(paste0(dataFolder,"lshData_AstAndProg.rds"))
unlink(paste0(tmpDataFolder,"tmpLshData/*"))


#### 4. generate layer info ####
# all FP lines
allFpLines <- unique(c(lshData$line1,lshData$line2))

rankLineByLayers <- function(newPrtData,allFpLines,folderPath = dataFolder){
  # Rabk lines by its depth in the pedigree tree. 
  # The most ancestral lines will get the lowest rank, which means will be generated its ancestral haplotypes first.
  
  layers_new <- newPrtData
  allAncestors <- unique(unlist(sapply(layers_new$includedAncestors,function(x){unlist(strsplit(x,";"))})))
  
  layers_new$pathLevel <- NA
  index <- 1:nrow(layers_new)
  level <- 0
  
  while(!all(layers_new$pedigree[index] %in% allAncestors)){
    index <- which(is.na(layers_new$pathLevel))
    allAncestors <- unique(unlist(sapply(layers_new$includedAncestors[index],function(x){unlist(strsplit(x,";"))})))
    layers_new$pathLevel[index] <- ifelse(layers_new$pedigree[index] %in% allAncestors, NA, level)
    level <- level + 1
  }
  
  layers_new$pathLevel[which(is.na(layers_new$pathLevel))] <- max(layers_new$pathLevel,na.rm=T) + 1
  layers_new$pathLevel <- max(layers_new$pathLevel,na.rm=T) - layers_new$pathLevel + 1
  
  layers_new <- layers_new %>% 
    arrange(pathLevel) %>% 
    mutate(inLSH = pedigree %in% allFpLines, Parents = includedAncestors )
  
  
  row.names(layers_new) <- layers_new$pedigree
  
  layers_new[newPrtData$pedigree,"directParents"] <- newPrtData[newPrtData$pedigree,"parents"]
  
  # all orphan lines and add to layer data
  allAsts <- unique(unlist(sapply(layers_new$includedAncestors,function(x){unlist(strsplit(x,";"))})))
  allOrphanLines <- allAsts[!allAsts %in% layers_new$pedigree]
  layers_new[allOrphanLines,] <- NA
  layers_new[allOrphanLines,"pathLevel"] <- 0
  layers_new[allOrphanLines,c("pedigree","originUsed","parents","includedAncestors","Parents","directParents")] <- allOrphanLines
  allPBHLines <- layers_new$pedigree
  
  
  # double check layers information; Lines with conflicted layer information. 
  
  layers_new$prtPath <- NA
  layers_new$validLevel <- NA
  
  for(i in 1:nrow(layers_new)){
    pLevel <- layers_new$pathLevel[i]
    if(pLevel == 0){
      layers_new$validLevel[i] <- "Yes"
    }else{
      prtLevels <- layers_new[unlist(strsplit(layers_new$includedAncestors[i],";")),"pathLevel"]
      layers_new$prtPath[i] <- paste(prtLevels,collapse = ";")
      layers_new$validLevel[i] <- ifelse(pLevel > max(prtLevels,na.rm = T),"Yes","No")
    }
    
  }
  
  # extract lines with conflict path; Tempoary assign these lines's pathLevel = 0 
  linesConflictPath <- subset(layers_new,validLevel == "No")$pedigree
  layers_new[linesConflictPath,"pathLevel"] <- 0
  
  
  saveRDS(layers_new,paste0(folderPath,"layers_new.rds"))
  return(layers_new)
  
  
}

# lines are problematic with pedigree (parents); excluded
# 1. NOTA230-HTT-T1B1 & NOTA230-HTT-T1B2 are mutal parents; 
# 2. DOLI576-KNF-T1A-Z, DOLI576-KNF-T1A1, DOLI576-KNF-T1A2
# 3. WMB4871-YCH-T1B1 & WMB4871-YCH-T1B2
# 4. TISI036-KDD-T1B1 & TISI036-KDD-T1B2
# 5. RETI083-SCV-T1C1 & RETI083-SCV-T1C-Z

newPrtData = newPrtData %>% filter(!pedigree %in% c("NOTA230-HTT-T1B1","NOTA230-HTT-T1B2","DOLI576-KNF-T1A-Z","DOLI576-KNF-T1A1","DOLI576-KNF-T1A2",
                                                    "RETI083-SCV-T1C-Z","RETI083-SCV-T1C1","WMB4871-YCH-T1B1","WMB4871-YCH-T1B2",
                                                    "TISI036-KDD-T1B1","TISI036-KDD-T1B2"))


layers_new <- rankLineByLayers(newPrtData, allFpLines)





#### 5. generate pbh ####              
totalBins <- nrow(newPredictionMap)
numCores <- detectCores()
numCores
registerDoParallel(numCores)

dirPath <- resultsFolder
dominoPath = "/domino/datasets/FP_Parental_Haplotypes/20221215/haploProbs/"
allPBHLines = layers_new$pedigree

for(level in 0:max(layers_new$pathLevel)){
  subLayersData <- layers_new %>% filter(pathLevel == level)
  #subLayersData <- layers_new %>% filter(pathLevel == level) %>% filter(!lineName %in% completedLines)
  print(paste("Processing... level",level,nrow(subLayersData),Sys.time()))
  if(nrow(subLayersData) == 0){next;}
  res <- foreach(count = 1:nrow(subLayersData),.combine=rbind) %dopar% {
    
    line <- subLayersData$pedigree[count]
    testAllPrts <- unlist(strsplit(layers_new[line,"Parents"],";"))
    
    if(file.exists(paste0(dirPath,"astHaploData/astHaploData_",line,".rds"))){
      return(line)
    }else if(layers_new[line,"pathLevel"] == 0 | all(file.exists(paste0(dirPath,"astHaploData/astHaploData_",testAllPrts,".rds")))){
      #if(file.exists(paste0("/mnt/results/PBH/astHaploData/astHaploData_",line,".rds"))){return(line)}
      generateAstHaplo(line,layers_new,lshData,allPBHLines,linesMissNames,hetRegionData,dirPath,dominoPath,totalBins)
    }else{}
    
  }
  
}  

# organize all data together

ancestralHaplo <- data.frame(index = 1:totalBins)
ancestralHaploProb <- data.frame(index = 1:totalBins)

timestamp()
for(i in 1:nrow(layers_new)){
  if(i %% 10000 == 0){print(paste(i,Sys.time()))}
  line <- layers_new$pedigree[i]
  if(file.exists(paste0(dirPath,"astHaploData/astHaploData_",line,".rds"))){
    ancestralHaplo[,line] <- readRDS(paste0(dirPath,"astHaploData/astHaploData_",line,".rds"))
  }
  
  if(file.exists(paste0(dirPath,"astHaploProb/astHaploProb_",line,".rds"))){
    ancestralHaploProb[,line] <- readRDS(paste0(dirPath,"astHaploProb/astHaploProb_",line,".rds"))
  }
  
  # if(file.exists(paste0("/mnt/results/PBH/parentalHaploProb/prtHaploProb_",line,".rds"))){
  #   parentalHaploProb[,line] <- readRDS(paste0("/mnt/results/PBH/parentalHaploProb/prtHaploProb_",line,".rds"))
  # }
  # 
  # if(file.exists(paste0("/mnt/results/PBH/parentalHaploData/prtHaploData_",line,".rds"))){
  #   parentalHaploData[,line] <- readRDS(paste0("/mnt/results/PBH/parentalHaploData/prtHaploData_",line,".rds"))
  # }
  
}


timestamp()
saveRDS(ancestralHaplo[,-1],file=paste0(resultsFolder,"ancestralHaplo_",haploVersion,".rds"))
timestamp()
saveRDS(round(ancestralHaploProb[,-1],4),file=paste0(resultsFolder,"ancestralHaploProb_",haploVersion,".rds"))

put_object("/mnt/results/PBH/ancestralHaplo_20220316.rds",object="tzuo/projects/AncestralHaplotypeCallers/2021V1/ancestralHaplo_20220316.rds",
           bucket= "bay-breeding-np-genome-analytics-635590664227", headers = c('x-amz-server-side-encryption' = 'AES256'))


put_object("/mnt/results/PBH/ancestralHaploProb_20220316.rds",object="tzuo/projects/AncestralHaplotypeCallers/2021V1/ancestralHaploProb_20220316.rds",
           bucket= "bay-breeding-np-genome-analytics-635590664227", headers = c('x-amz-server-side-encryption' = 'AES256'))






#### functions ####

generateAstHaplo <- function(line,layers_new,lshData,allPBHLines,linesMissNames,hetRegionData,dirPath,dominoPath,totalBins){
  
  #if(layers_new[line,"oldPathLevel"] == 0){return(paste0(level,"_",count))}
  #if(is.na(layers_new[line,"directParents"])){return(paste0(level,"_",count))}
  #if(layers_new[line,"oldPathLevel"] == 0 | !line %in% allPrgLines | layers_new[line,"pathLevel"] == 1 | is.na(layers_new[line,"directParents"])){
  if(layers_new[line,"pathLevel"] <=0){ 
    prtHaplo <- rep(line,totalBins)
    prtHaplo <- assignHetOtherToHet(line,prtHaplo,hetRegionData,allPBHLines)
    saveRDS(prtHaplo,paste0(dirPath,"parentalHaploData/prtHaploData_",line,".rds"))
    saveRDS(rep(1,totalBins),paste0(dirPath,"parentalHaploProb/prtHaploProb_",line,".rds"))
    saveRDS(prtHaplo,paste0(dirPath,"astHaploData/astHaploData_",line,".rds"))
    saveRDS(rep(1,totalBins),paste0(dirPath,"astHaploProb/astHaploProb_",line,".rds"))
  }else{
    
    # 1. pull parental prob data from Danny's parental call
    lineProbData <- getParentalProbAllbyLine(line,dominoPath,linesMissNames)
    if(nrow(lineProbData) < totalBins){return(line)}
    allPrts <- sort(colnames(lineProbData)[4:(ncol(lineProbData)-1)])
    #allPrts <- sort(unlist(strsplit(layers_new[line,"Parents"],";")))
    directPrts <- sort(unlist(strsplit(layers_new[line,"directParents"],";")))
    
    # direct parents not in allPrts; Skip to next;
    if(!all(directPrts[directPrts %in% allPBHLines] %in% allPrts)){return(line)}
    
    # 2. modify parentalProb
    if(length(allPrts) > 1){
      # 3. find the maxProb, maxProbLine, etc
      lineProbData$top2Prob <- apply(lineProbData[,2:(4+length(allPrts)-1)],1,
                                     function(x){ y = sort(x,decreasing = T);x = sort(x[3:length(x)],decreasing = T);
                                     return(paste(y[1],names(y)[1],x[1],x[2],names(x)[1],names(x)[2],sep=";"))})
      
      lineProbData <- lineProbData %>% separate(top2Prob,c("maxProb","maxProbLine","maxProbPrt","secMaxProbPrt","maxProbPrtLine","secMaxProbPrtLine"),sep=";")
      lineProbData$maxProbPrt <- as.numeric(lineProbData$maxProbPrt)
      lineProbData$secMaxProbPrt <- as.numeric(lineProbData$secMaxProbPrt)
      lineProbData$maxProb <- as.numeric(lineProbData$maxProb)
      
      # 3.1 read the allPrts' ancestral haplos and ancestral haploProb
      astData <- data.frame(index = 1:totalBins)
      for(prt in allPrts){
        if(prt %in% allPBHLines){
          if(file.exists(paste0(dirPath,"astHaploData/astHaploData_",prt,".rds"))){
            astData[,prt] <- readRDS(paste0(dirPath,"astHaploData/astHaploData_",prt,".rds"))
          }
          
        }else{
          astData[,prt] <- rep(prt,totalBins)
        }
      }
      
      astHaploProb <- data.frame(index = 1:totalBins)
      for(prt in allPrts){
        if(prt %in% allPBHLines){
          if(file.exists(paste0(dirPath,"astHaploProb/astHaploProb_",prt,".rds"))){
            astHaploProb[,prt] <- readRDS(paste0(dirPath,"astHaploProb/astHaploProb_",prt,".rds"))
          }
          
        }else{
          astHaploProb[,prt] <- rep(1,totalBins)
        }
      }
      
      
      # 3.2 modify parentalProb
      lineProbDataNew <- bind_cols(lineProbData[,(5+length(allPrts)):ncol(lineProbData)],astData)
      
      probRes <- data.frame()
      
      # 3.2.1. keep prob>=0.9
      probRes <- bind_rows(probRes,lineProbDataNew %>% 
                             filter((maxProb >= 0.9 & maxProbLine != "Heterozygous") | 
                                      (maxProb >= 0.95 & maxProbLine == "Heterozygous")))
      
      # 3.2.2. keep max(Prob) == "Heterozygous" & sameHaplo(directPrts)
      if(all(directPrts %in% allPBHLines) & length(directPrts) > 1){
        tmp1 <- lineProbDataNew %>% filter(maxProb < 0.95, maxProbLine == "Heterozygous")
        
        if(nrow(tmp1) > 0){
          tmp1_1 <- tmp1[,directPrts]
          numOfHaplo <- apply(tmp1_1,1,function(x){length(unique(x))})
          
          # if same ancestral haplo for all the direct parents; add prob together and take the max line as maxProbLine
          posIndex <- which(numOfHaplo == 1)
          tmp1[posIndex,"maxProb"] <- apply(lineProbData[tmp1[posIndex,"index"],c("Heterozygous",directPrts)],1,sum)
          higherHetPrtIndex <- apply(lineProbData[tmp1[posIndex,"index"],directPrts],1,which.max)
          tmp1[posIndex,"maxProbLine"] <- directPrts[higherHetPrtIndex]
          
          # handle heterozygous by descent; if 1) two parents 2) both FP'ed; 3) shared LSH; 4)Not masked as Het, set as homo and pick the highest prob line. 
          if(length(directPrts) == 2 & all(directPrts %in% allPBHLines)){
            
            lineHetData <- hetRegionData %>% filter(V1 == line) 
            lineHetRegion <- unlist(apply(lineHetData[,c("start_index","end_index")],1,function(x){return(x[1]:x[2])}))
            
            prtLshData <- lshData %>% filter(line1 %in% directPrts & line2 %in% directPrts)
            sharedPrtLSH <- unlist(apply(prtLshData[,c("start_index_map","end_index_map")],1,function(x){return(x[1]:x[2])}))
            
            hbdIndex <- which(tmp1$maxProbLine == "Heterozygous" & tmp1$index %in% sharedPrtLSH & !(tmp1$index %in% lineHetRegion))
            tmp1[hbdIndex,"maxProb"] <- apply(lineProbData[tmp1[hbdIndex,"index"],c("Heterozygous",directPrts)],1,sum)
            higherHbdPrtIndex <- apply(lineProbData[tmp1[hbdIndex,"index"],directPrts],1,which.max)
            tmp1[hbdIndex,"maxProbLine"] <- directPrts[higherHbdPrtIndex]
          }
          
          
          
          probRes <- bind_rows(probRes,tmp1)
          
        }
      }else{ # adding [0.9,0.95) het back; because of the het threhold is raised from 0.9 to 0.95
        tmp1 <- lineProbDataNew %>% filter(maxProb < 0.95, maxProb >= 0.9, maxProbLine == "Heterozygous")
        probRes <- bind_rows(probRes,tmp1)
      }
      
      
      # 3.2.3. Sum (all direct parents or top2) >= 0.9 &  same (all parents’ haplotype or top2)
      tmp2 <- lineProbDataNew %>% filter(maxProb < 0.9, secMaxProbPrt >= 0.1, (maxProbPrt + secMaxProbPrt) >= 0.9, maxProbLine != "Heterozygous")
      if(nrow(tmp2) > 0){
        sameHaplo <- apply(tmp2[,5:ncol(tmp2)],1,function(x){if(x[x[1]] == x[x[2]]){return(1)}else(return(0))})
        posIndex <- which(sameHaplo == 1)
        if(length(posIndex) > 0){
          tmp2$maxProb <- tmp2$maxProbPrt + tmp2$secMaxProbPrt
          probRes <- bind_rows(probRes,tmp2[posIndex,])
        }
      }
      
      # 3.2.4. set others to 1
      tmp3 <- lineProbDataNew %>% filter(maxProb < 0.9, maxProbLine == "Other" | !index %in% probRes$index )
      if(nrow(tmp3) > 0){
        tmp3$maxProb <- 1
        tmp3$maxProbLine <- "Other"
        probRes <- bind_rows(probRes,tmp3) %>% arrange(index)
      }
      
      probRes <- probRes %>% arrange(index)
      
      # 4. parse Het regions
      parsedHaploData <- parseHetRegions(line,layers_new,probRes$maxProbLine,astData,hetRegionData,allPBHLines)
      prtHaplos <- parsedHaploData$prtHaplo
      astHaplos <- parsedHaploData$astHaplo
      probRes$maxProbLine <- prtHaplos
      
      # 5. convert to ancestral haplotypes
      astHaploData <- convertPrtToAst(line,prtHaplos,astHaplos,astData,allPrts,astHaploProb)
      astHaplos <- astHaploData$astHaplo
      astProbs <- probRes$maxProb * astHaploData$astProb
      
      # 6. use LSH to fill "Others" >= 10 bins (1 cM); skip if line is not having LSH data
      if(layers_new[line,"inLSH"] == "TRUE"){
        lineProbData$haplo <- astHaplos
        lineProbData$index <- 1:totalBins
        lineProbDataHaplo <- lineProbData %>% filter(haplo == line)
        if(nrow(lineProbDataHaplo) > 0){
          otherHaploTable <- convertOtherToHaploTable(lineProbDataHaplo)
          if(nrow(otherHaploTable) > 0){
            otherHaploTable <- otherHaploTable %>% filter((end_index - start_index) >= 10)
            if(nrow(otherHaploTable) > 0){
              lsh <- lshData %>% filter((line1 == line & line2 %in% allPrts) | (line2 == line & line1 %in% allPrts)) %>% arrange(line1,line2,start_index)
              lshHaplos <- findLineShareOther(line,otherHaploTable,lsh,allPrts,lineProbData)
              lshHaplos <- lshHaplos[lshHaplos != line] # remove itself
              # 7. convert to ancestral haplotypes; add to parental haplotypes
              if(length(lshHaplos) > 0){
                prtHaplos[as.numeric(names(lshHaplos))] <- lshHaplos
                probRes$maxProbLine[as.numeric(names(lshHaplos))] <- lshHaplos
                probRes$maxProb[as.numeric(names(lshHaplos))] <- 0.9
                astHaploData2 <- convertPrtToAst(line,prtHaplos,astHaplos,astData,allPrts,astHaploProb)
                astHaplos <- astHaploData2$astHaplos
                astProbs <- probRes$maxProb * astHaploData2$astProb
                index_self <- which(astHaploData2$astHaplos == line)
                astProbs[index_self] <- 1
                
              }
            }
          }
        }
      }
      
      
    }else{
      lineProbData$top2Prob <- apply(lineProbData[,2:(4+length(allPrts)-1)],1,
                                     function(x){ y = sort(x,decreasing = T);
                                     return(paste(y[1],names(y)[1],sep=";"))})
      lineProbData <- lineProbData %>% separate(top2Prob,c("maxProb","maxProbLine"),sep=";")
      lineProbData$maxProb <- as.numeric(lineProbData$maxProb)
      
      lowProbBinIndex <- which(lineProbData$maxProb < 0.9 & lineProbData$maxProbLine != "Heterozygous")
      if(length(lowProbBinIndex) > 0){ # convert low probability bins into "Other" and set prob. as 1.
        lineProbData[lowProbBinIndex,"maxProb"] <- 1
        lineProbData[lowProbBinIndex,"maxProbLine"] <- "Other"
      }
      
      # 3.1 read the allPrts' ancestral haplos and ancestral haploProb
      astData <- data.frame(index = 1:totalBins)
      for(prt in allPrts){
        if(prt %in% allPBHLines){
          if(file.exists(paste0(dirPath,"astHaploData/astHaploData_",prt,".rds"))){
            astData[,prt] <- readRDS(paste0(dirPath,"astHaploData/astHaploData_",prt,".rds"))
          }
          
        }else{
          astData[,prt] <- rep(prt,totalBins)
        }
      }
      
      astHaploProb <- data.frame(index = 1:totalBins)
      for(prt in allPrts){
        if(prt %in% allPBHLines){
          if(file.exists(paste0(dirPath,"astHaploProb/astHaploProb_",prt,".rds"))){
            astHaploProb[,prt] <- readRDS(paste0(dirPath,"astHaploProb/astHaploProb_",prt,".rds"))
          }
          
        }else{
          astHaploProb[,prt] <- rep(1,totalBins)
        }
      }
      
      # one of the direct parent has ancestralHaplo
      if(allPrts %in% directPrts & length(directPrts) == 2){
        hetRegions <- which(lineProbData$maxProbLine == "Heterozygous")
        numOfHetRegion <- length(hetRegions)
        if(numOfHetRegion > 0){
          hetHaplos <- rep(paste0(line,"_het"),numOfHetRegion)
          hetHaploData <- parseHetRegionOneParent(hetHaplos,astData[hetRegions,allPrts],allPrts)
          lineProbData$maxProbLine[hetRegions] <- hetHaploData$hetHaplos
          
        }
      }
      
      probRes <- lineProbData[,c("maxProb","maxProbLine")]
      probRes$maxProbLine[which(probRes$maxProbLine == "Heterozygous")] <- paste(line,"het",sep="_")
      
      binsToAst <- which(probRes$maxProbLine == allPrts)
      if(length(binsToAst) > 0){
        probRes$maxProbLine[binsToAst] <- astData[binsToAst,allPrts]
        probRes$maxProb[binsToAst] <- probRes$maxProb[binsToAst] * astHaploProb[binsToAst,allPrts]
      }
      
      binsToSelf <- which(probRes$maxProbLine == "Other")
      if(length(binsToSelf) > 0){
        probRes$maxProbLine[binsToSelf] <- line
        probRes$maxProb[binsToSelf] <- 1
      }
      
      
      binsToHet <- which(str_detect(probRes$maxProbLine,"&\\?"))
      if(length(binsToHet) > 0){
        probRes$maxProb[binsToHet] <- probRes$maxProb[binsToHet] * astHaploProb[binsToHet,allPrts]
      }
      
      astProbs <- probRes$maxProb
      astHaplos <- probRes$maxProbLine
      
    }
    
    
    # save the data
    parentalHaplos <- str_replace_all(probRes$maxProbLine,"Other",line)
    astHaplos <- str_replace_all(astHaplos,"Other",line)
    saveRDS(astHaplos,paste0(dirPath,"astHaploData/astHaploData_",line,".rds"))
    saveRDS(astProbs,paste0(dirPath,"astHaploProb/astHaploProb_",line,".rds"))
  }
  return(line)
  
}

# generateAstHaplo <- function(line,layers_new,lshData,allPBHLines,hetRegionData){
#   totalBins <- 17116
#   
#   #if(layers_new[line,"oldPathLevel"] == 0){return(paste0(level,"_",count))}
#   #if(is.na(layers_new[line,"directParents"])){return(paste0(level,"_",count))}
#   #if(layers_new[line,"oldPathLevel"] == 0 | !line %in% AaaSOrigins | layers_new[line,"pathLevel"] == 1 | is.na(layers_new[line,"directParents"])){
#   if(layers_new[line,"pathLevel"] <=1){ 
#     prtHaplo <- rep(line,totalBins)
#     prtHaplo <- assignHetOtherToHet(line,prtHaplo,hetRegionData,allPBHLines)
#     saveRDS(prtHaplo,paste0("/mnt/results/PBH/parentalHaploData/prtHaploData_",line,".rds"))
#     saveRDS(rep(1,totalBins),paste0("/mnt/results/PBH/parentalHaploProb/prtHaploProb_",line,".rds"))
#     saveRDS(prtHaplo,paste0("/mnt/results/PBH/astHaploData/astHaploData_",line,".rds"))
#     saveRDS(rep(1,totalBins),paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",line,".rds"))
#   }else{
#     
#     # 1. pull parental prob data from Danny's parental call
#     lineProbData <- getParentalProbAllbyLine(line,dominoPath,linesMissNames)
#     allPrts <- sort(colnames(lineProbData)[4:(ncol(lineProbData)-1)])
#     #allPrts <- sort(unlist(strsplit(layers_new[line,"Parents"],";")))
#     directPrts <- sort(unlist(strsplit(layers_new[line,"directParents"],";")))
#     
#     # direct parents not in allPrts; Skip to next;
#     if(!all(directPrts[directPrts %in% allPBHLines] %in% allPrts)){return(line)}
#     
#     # 2. modify parentalProb
#     if(length(allPrts) > 1){
#       # 3. find the maxProb, maxProbLine, etc
#       lineProbData$top2Prob <- apply(lineProbData[,2:(4+length(allPrts)-1)],1,
#                                      function(x){ y = sort(x,decreasing = T);x = sort(x[3:length(x)],decreasing = T);
#                                      return(paste(y[1],names(y)[1],x[1],x[2],names(x)[1],names(x)[2],sep=";"))})
#       
#       lineProbData <- lineProbData %>% separate(top2Prob,c("maxProb","maxProbLine","maxProbPrt","secMaxProbPrt","maxProbPrtLine","secMaxProbPrtLine"),sep=";")
#       lineProbData$maxProbPrt <- as.numeric(lineProbData$maxProbPrt)
#       lineProbData$secMaxProbPrt <- as.numeric(lineProbData$secMaxProbPrt)
#       lineProbData$maxProb <- as.numeric(lineProbData$maxProb)
#       
#       # 3.1 read the allPrts' ancestral haplos and ancestral haploProb
#       astData <- data.frame(index = 1:totalBins)
#       for(prt in allPrts){
#         if(prt %in% allPBHLines){
#           if(file.exists(paste0("/mnt/results/PBH/astHaploData/astHaploData_",prt,".rds"))){
#             astData[,prt] <- readRDS(paste0("/mnt/results/PBH/astHaploData/astHaploData_",prt,".rds"))
#           }
#           
#         }else{
#           astData[,prt] <- rep(prt,totalBins)
#         }
#       }
#       
#       astHaploProb <- data.frame(index = 1:totalBins)
#       for(prt in allPrts){
#         if(prt %in% allPBHLines){
#           if(file.exists(paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",prt,".rds"))){
#             astHaploProb[,prt] <- readRDS(paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",prt,".rds"))
#           }
#           
#         }else{
#           astHaploProb[,prt] <- rep(1,totalBins)
#         }
#       }
#       
#       
#       # 3.2 modify parentalProb
#       lineProbDataNew <- bind_cols(lineProbData[,(5+length(allPrts)):ncol(lineProbData)],astData)
#       
#       probRes <- data.frame()
#       
#       # 3.2.1. keep prob>=0.9
#       probRes <- bind_rows(probRes,lineProbDataNew %>% filter(maxProb >= 0.9))
#       
#       # 3.2.2. keep max(Prob) == "Heterozygous" & sameHaplo(directPrts)
#       if(all(directPrts %in% allPBHLines) & length(directPrts) > 1){
#         tmp1 <- lineProbDataNew %>% filter(maxProb < 0.9, maxProbLine == "Heterozygous")
#         
#         if(nrow(tmp1) > 0){
#           tmp1_1 <- tmp1[,directPrts]
#           numOfHaplo <- apply(tmp1_1,1,function(x){length(unique(x))})
#           posIndex <- which(numOfHaplo == 1)
#           tmp1[posIndex,"maxProb"] <- apply(lineProbData[tmp1[posIndex,"index"],c("Heterozygous",directPrts)],1,sum)
#           higherHetPrtIndex <- apply(lineProbData[tmp1[posIndex,"index"],directPrts],1,which.max)
#           tmp1[posIndex,"maxProbLine"] <- directPrts[higherHetPrtIndex]
#           probRes <- bind_rows(probRes,tmp1)
#           
#         }
#       }
#       
#       # 3.2.3. Sum (all direct parents or top2) >= 0.9 &  same (all parents’ haplotype or top2)
#       tmp2 <- lineProbDataNew %>% filter(maxProb < 0.9, secMaxProbPrt >= 0.1, (maxProbPrt + secMaxProbPrt) >= 0.9)
#       if(nrow(tmp2) > 0){
#         sameHaplo <- apply(tmp2[,5:ncol(tmp2)],1,function(x){if(x[x[1]] == x[x[2]]){return(1)}else(return(0))})
#         posIndex <- which(sameHaplo == 1)
#         if(length(posIndex) > 0){
#           tmp2$maxProb <- tmp2$maxProbPrt + tmp2$secMaxProbPrt
#           probRes <- bind_rows(probRes,tmp2[posIndex,])
#         }
#       }
#       
#       # 3.2.4. set others to 1
#       tmp3 <- lineProbDataNew %>% filter(maxProb < 0.9, maxProbLine == "Other" | !index %in% probRes$index )
#       if(nrow(tmp3) > 0){
#         tmp3$maxProb <- 1
#         tmp3$maxProbLine <- "Other"
#         probRes <- bind_rows(probRes,tmp3) %>% arrange(index)
#       }
#       
#       probRes <- probRes %>% arrange(index)
#       
#       # 4. parse Het regions
#       parsedHaploData <- parseHetRegions(line,layers_new,probRes$maxProbLine,astData,hetRegionData,allPBHLines)
#       prtHaplos <- parsedHaploData$prtHaplo
#       astHaplos <- parsedHaploData$astHaplo
#       probRes$maxProbLine <- prtHaplos
#       
#       # 5. convert to ancestral haplotypes
#       astHaploData <- convertPrtToAst(line,prtHaplos,astHaplos,astData,allPrts,astHaploProb)
#       astHaplos <- astHaploData$astHaplo
#       astProbs <- probRes$maxProb * astHaploData$astProb
#       
#       # 6. use LSH to fill "Others" >= 10 bins (1 cM); skip if line is not having LSH data
#       if(layers_new[line,"inLSH"] == "TRUE"){
#         lineProbData$haplo <- astHaplos
#         lineProbData$index <- 1:totalBins
#         lineProbDataHaplo <- lineProbData %>% filter(haplo == line)
#         if(nrow(lineProbDataHaplo) > 0){
#           otherHaploTable <- convertOtherToHaploTable(lineProbDataHaplo)
#           if(nrow(otherHaploTable) > 0){
#             otherHaploTable <- otherHaploTable %>% filter((end_index - start_index) >= 10)
#             if(nrow(otherHaploTable) > 0){
#               lsh <- lshData %>% filter((line1 == line & line2 %in% allPrts) | (line2 == line & line1 %in% allPrts)) %>% arrange(line1,line2,start_index)
#               lshHaplos <- findLineShareOther(line,otherHaploTable,lsh,allPrts,lineProbData)
#               lshHaplos <- lshHaplos[lshHaplos != line] # remove itself
#               # 7. convert to ancestral haplotypes; add to parental haplotypes
#               if(length(lshHaplos) > 0){
#                 prtHaplos[as.numeric(names(lshHaplos))] <- lshHaplos
#                 probRes$maxProbLine[as.numeric(names(lshHaplos))] <- lshHaplos
#                 probRes$maxProb[as.numeric(names(lshHaplos))] <- 0.9
#                 astHaploData2 <- convertPrtToAst(line,prtHaplos,astHaplos,astData,allPrts,astHaploProb)
#                 astHaplos <- astHaploData2$astHaplos
#                 astProbs <- probRes$maxProb * astHaploData2$astProb
#                 index_self <- which(astHaploData2$astHaplos == line)
#                 astProbs[index_self] <- 1
#                 
#               }
#             }
#           }
#         }
#       }
#       
#       
#     }else{
#       lineProbData$top2Prob <- apply(lineProbData[,2:(4+length(allPrts)-1)],1,
#                                      function(x){ y = sort(x,decreasing = T);
#                                      return(paste(y[1],names(y)[1],sep=";"))})
#       lineProbData <- lineProbData %>% separate(top2Prob,c("maxProb","maxProbLine"),sep=";")
#       lineProbData$maxProb <- as.numeric(lineProbData$maxProb)
#       
#       lowProbBinIndex <- which(lineProbData$maxProb < 0.9 & lineProbData$maxProbLine != "Heterozygous")
#       if(length(lowProbBinIndex) > 0){ # convert low probability bins into "Other" and set prob. as 1.
#         lineProbData[lowProbBinIndex,"maxProb"] <- 1
#         lineProbData[lowProbBinIndex,"maxProbLine"] <- "Other"
#       }
#       
#       # 3.1 read the allPrts' ancestral haplos and ancestral haploProb
#       astData <- data.frame(index = 1:totalBins)
#       for(prt in allPrts){
#         if(prt %in% allPBHLines){
#           if(file.exists(paste0("/mnt/results/PBH/astHaploData/astHaploData_",prt,".rds"))){
#             astData[,prt] <- readRDS(paste0("/mnt/results/PBH/astHaploData/astHaploData_",prt,".rds"))
#           }
#           
#         }else{
#           astData[,prt] <- rep(prt,totalBins)
#         }
#       }
#       
#       astHaploProb <- data.frame(index = 1:totalBins)
#       for(prt in allPrts){
#         if(prt %in% allPBHLines){
#           if(file.exists(paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",prt,".rds"))){
#             astHaploProb[,prt] <- readRDS(paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",prt,".rds"))
#           }
#           
#         }else{
#           astHaploProb[,prt] <- rep(1,totalBins)
#         }
#       }
#       
#       # one of the direct parent has ancestralHaplo
#       if(allPrts %in% directPrts & length(directPrts) == 2){
#         hetRegions <- which(lineProbData$maxProbLine == "Heterozygous")
#         numOfHetRegion <- length(hetRegions)
#         if(numOfHetRegion > 0){
#           hetHaplos <- rep(paste0(line,"_het"),numOfHetRegion)
#           hetHaploData <- parseHetRegionOneParent(hetHaplos,astData[hetRegions,allPrts],allPrts)
#           lineProbData$maxProbLine[hetRegions] <- hetHaploData$hetHaplos
#           
#         }
#       }
#       
#       probRes <- lineProbData[,c("maxProb","maxProbLine")]
#       probRes$maxProbLine[which(probRes$maxProbLine == "Heterozygous")] <- paste(line,"het",sep="_")
#       
#       binsToAst <- which(probRes$maxProbLine == allPrts)
#       if(length(binsToAst) > 0){
#         probRes$maxProbLine[binsToAst] <- astData[binsToAst,allPrts]
#         probRes$maxProb[binsToAst] <- probRes$maxProb[binsToAst] * astHaploProb[binsToAst,allPrts]
#       }
#       
#       binsToSelf <- which(probRes$maxProbLine == "Other")
#       if(length(binsToSelf) > 0){
#         probRes$maxProbLine[binsToSelf] <- line
#         probRes$maxProb[binsToSelf] <- 1
#       }
#       
#       
#       binsToHet <- which(str_detect(probRes$maxProbLine,"&\\?"))
#       if(length(binsToHet) > 0){
#         probRes$maxProb[binsToHet] <- probRes$maxProb[binsToHet] * astHaploProb[binsToHet,allPrts]
#       }
#       
#       astProbs <- probRes$maxProb
#       astHaplos <- probRes$maxProbLine
#       
#     }
#     
#     
#     # save the data
#     parentalHaplos <- str_replace_all(probRes$maxProbLine,"Other",line)
#     astHaplos <- str_replace_all(astHaplos,"Other",line)
#     #saveRDS(parentalHaplos,paste0("/mnt/results/PBH/parentalHaploData/prtHaploData_",line,".rds"))
#     #saveRDS(probRes$maxProb,paste0("/mnt/results/PBH/parentalHaploProb/prtHaploProb_",line,".rds"))
#     saveRDS(astHaplos,paste0("/mnt/results/PBH/astHaploData/astHaploData_",line,".rds"))
#     saveRDS(astProbs,paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",line,".rds"))
#   }
#   return(line)
#   
# }
# 


getParentalProbAllbyLine <- function(line,dominoPath,linesMissNames){
  #line <- str_replace_all(line,":|@|<|>|\\(|\\)|\\^|#|&","_")  # :,@,<,> has been repalced by "_", for example,H3_DIDA406<ZM_S390777>:@.0004.@.
  
  if(line %in% names(linesMissNames)){ # New problems with changed lineNames
    line <- linesMissNames[line]
  }
  
  parentalProbData <- data.frame()
  for(chr in 1:10){
    fileName <- paste0(dominoPath,line,"_chr",chr,".csv.gz")
    if(!file.exists(fileName)){next;}
    parentalProb <- read.csv(gzfile(fileName), check.names = F)
    colnames(parentalProb)[1] <- "genMapPos"
    parentalProb$genMapChr <- chr
    parentalProbData <- bind_rows(parentalProbData,parentalProb)
    
  }
  #parentalProbData <- parentalProbData %>% gather(key = "type",value = "prob",2:(ncol(parentalProbData)-1))
  
  return(parentalProbData)
  
}

assignHetOtherToHet <- function(line,prtHaplo,hetRegionData,allAstLines = allPBHLines){
  # assign regions that are ("other" in PBH & "Heterozygous") in LSH to "line_het"
  if(line %in% unique(hetRegionData$V1) & line %in% allAstLines){
    selfRegions <- which(prtHaplo == line)
    subHetRegionData <- hetRegionData %>% filter(V1 == line)
    subHetRegions <- unlist(apply(subHetRegionData,1,function(x){return(x[11]:x[12])}))
    selfHetRegions <- selfRegions[selfRegions %in% subHetRegions]
    if(length(selfHetRegions) > 0){prtHaplo[selfHetRegions] <- paste0(line,"_het")}
  }
  return(prtHaplo)
}

parseHetRegions <- function(line,layers_new,prtHaplo,prtAstData,hetRegionData,allAstLines){
  # return parsed het regions at both parental and ancestral levels, because:
  # regions could be het at parental level but not necessary at the ancestral level; 
  
  
  # step 1. get direct parents and all parents used in Parental calls
  pathLevel <- layers_new[line,"pathLevel"]
  prts <- sort(unlist(strsplit(layers_new[line,"directParents"],";")))
  numOfPrt <- length(prts)
  allPrts <- sort(unlist(strsplit(layers_new[line,"Parents"],";")))
  
  if(numOfPrt == 0){return(list(prtHaplo=prtHaplo,astHaplo=prtHaplo))} # none direct parent is FP'ed
  
  # step 2. assign regions that are ("other" in PBH & "Heterozygous") in LSH to "line_het"
  prtHaplo <- assignHetOtherToHet(line,prtHaplo,hetRegionData,allPBHLines)
  
  # step 3. skip lines with pathLevel ==  1; no parents
  if(pathLevel == 1){return(list(prtHaplo=prtHaplo,astHaplo=prtHaplo))} 
  
  # step 5. parse "Heterozygous" regions
  astHaplo <- prtHaplo
  if(line %in% allAstLines){
    prts <- prts[prts %in% allAstLines]
    numOfAstPrt <- length(prts)
    hetRegions <- which(prtHaplo == "Heterozygous")
    numOfHetRegion <- length(hetRegions)
    if(numOfHetRegion == 0){return(list(prtHaplo=prtHaplo,astHaplo=prtHaplo))} # if no "Heterozygous", skip;
    hetHaplos <- rep(paste0(line,"_het"),numOfHetRegion)
    hetHaploPrt <- hetHaplos
    
    #stp 5_0: skip lines that are questionable (with direct parents not in all parents, or without directParents or all directParents are not FP'ed)
    if(numOfPrt == 0 | numOfAstPrt == 0){prtHaplo[hetRegions] <- hetHaplos;return(list(prtHaplo=prtHaplo,astHaplo=prtHaplo))}
    
    #step 5_1: only one parent
    if(numOfPrt == 1){
      if(numOfAstPrt == 1){
        hetHaploData <- parseHetRegionOneParent(hetHaplos,prtAstData[hetRegions,prts],prts)
        hetHaplos <- hetHaploData$hetHaplos
        hetHaploPrt <- hetHaploData$hetHaploPrt
      }
    }
    
    #step 5_2: two parents
    if(numOfPrt == 2){
      # step 5_2_1: both parents are not FP'ed
      #if(numOfAstPrt == 0){} # do nothing
      
      # step 5_2_2: one parent is not FP'ed
      if(numOfAstPrt == 1){hetHaploData <- parseHetRegionOneParent(hetHaplos,prtAstData[hetRegions,prts],prts)}
      
      # step 5_2_3: both parents are present
      if(numOfAstPrt == 2){hetHaploData <- parseHetRegionTwoParents(hetHaplos,prtAstData[hetRegions,prts],prts)}
      
      hetHaplos <- hetHaploData$hetHaplos
      hetHaploPrt <- hetHaploData$hetHaploPrt
    }
    
    #step 5_3: more than 2 parents
    if(numOfPrt >= 3){ # at least three parents
      
      # step 5_3_1: no more than one missing
      if(numOfPrt - numOfAstPrt <= 1) {
        tmpAstTable <- prtAstData[hetRegions,prts]
        numOfUniqHaplos <- apply(tmpAstTable,1,function(x){y <- unique(unlist(strsplit(x,"&|\\|"))); return(length(y))})
        combHaplos <- apply(tmpAstTable,1,function(x){y <- sort(unique(unlist(strsplit(x,"&|\\|")))); return(paste(y,collapse = "&"))})
        
        # no missing prt
        if(numOfPrt == numOfAstPrt){
          pos <- which(numOfUniqHaplos == 1) # all prts have the same haplo;
          if(length(pos) > 0 ){hetHaplos[pos] <- combHaplos[pos];hetHaploPrt[pos] <- paste(prts,collapse = "&")}
          pos <- which(numOfUniqHaplos == 2) # two unique haplos
          if(length(pos) > 0 ){hetHaplos[pos] <- combHaplos[pos];hetHaploPrt[pos] <- paste(prts,collapse = "&")}
          #pos <- which(numOfUniqHaplos > 2) #more than 2 unique haplos; Do nothing
        }
        
        # missing 1 prt
        if(numOfPrt - numOfAstPrt == 1){ 
          pos <- which(numOfUniqHaplos == 1) # 1 unique haplo
          if(length(pos) > 0 ){hetHaplos[pos] <- paste(combHaplos[pos],"&?",sep="");hetHaploPrt[pos] <- paste(paste(prts,collapse = "|"),"&?",sep="") }
          #pos <- which(numOfUniqHaplos >= 2) # more than 1 unique haplo; Do nothing
        }
        
      }
      
      # step 5_3_2: more than one missing; Do nothing
    }
    
    # assing new values to heterozygous regions
    prtHaplo[hetRegions] <- hetHaploPrt
    astHaplo[hetRegions] <- hetHaplos
  }
  return(list(prtHaplo=prtHaplo,astHaplo=astHaplo))
}

parseHetRegionOneParent <- function(hetHaplos,prtHaplos,prts){
  # hetHaplos is the regions where the query line is "Heterozygous";
  # prtHaplo is the only parent's haplotype at the same region
  # parse hetHaplo based on the only parent's haplotype (prtHaplo)
  haploPatterns <- unique(prtHaplos)
  hetHaploPrt <- hetHaplos
  for(pat in haploPatterns){
    pos <- which(prtHaplos == pat)
    if(str_detect(pat,"\\|") ){ #5_2_2_1: parental haplo is het and with a complciated pattern;
      #layers_new$type1_1[i] <- layers_new$type1_1[i] + length(pos)
    }else if(str_detect(pat,"_het")){ #t_2_2_2: parental haplo is line_prt
      #layers_new$type1_2[i] <- layers_new$type1_2[i] + length(pos)
    }else if(str_detect(pat,"&")){ #5_2_2_3: parental haplo is A&B
      hetHaplos[pos] <- paste0("(",paste(sort(unique(unlist(strsplit(pat,"&")))),collapse="|"),")&?")
      hetHaploPrt[pos] <- paste0(prts,"&?")
      #layers_new$type1_3[i] <- layers_new$type1_3[i] + length(pos)
    }else { #5_2_2_4: parental haplo is A
      hetHaplos[pos] <- paste0(pat,"&?")
      hetHaploPrt[pos] <- paste0(prts,"&?")
      #layers_new$type1_4[i] <- layers_new$type1_4[i] + length(pos)
    }
  }
  return(list(hetHaplos=hetHaplos,hetHaploPrt = hetHaploPrt))
}

parseHetRegionTwoParents <- function(hetHaplos,tmpAstTable,prts){
  # hetHaplos is the regions where the query line is "Heterozygous";
  # tmpAst is the data frame with two parents' haplotype data
  # parse hetHaplo based on the parent's haplotype (prtHaplo)
  
  tmpAstTable$pattern <- apply(tmpAstTable,1,function(x){return(paste(x,collapse =";"))})
  haploPatterns <- unique(tmpAstTable$pattern)
  hetHaploPrt <- hetHaplos
  
  for(pat in haploPatterns){
    pos <- which(tmpAstTable$pattern == pat)
    astHaplos <- sort(unlist(strsplit(pat,";")))
    
    if(str_detect(pat,"\\|")){ # 2_2_1: at least one parental haplo is het and with a complciated pattern;
      
    }else if(str_detect(pat,"_het")){ #2_2_2: at least one parental haplo is line_prt
      
    }else if(str_count(pat,"&") == 2){ # both parents are het
      if(astHaplos[1] == astHaplos[2]){ # parents are the same haplos
        hetHaplos[pos] <- astHaplos[1]
        hetHaploPrt[pos] <- paste(prts,collapse = "&")
      }else{
        
      }
    }else if (str_count(pat,"&") == 1){ # one is homo and the other is het
      astHaplos1 <- sort(unique(unlist(strsplit(astHaplos[1],"&"))))
      astHaplos2 <- sort(unique(unlist(strsplit(astHaplos[2],"&"))))
      hetHaploPrt[pos] <- paste(prts,collapse = "&")
      if(all(astHaplos1 %in% astHaplos2) | all(astHaplos2 %in% astHaplos1)) { # (A & B, A)
        hetHaplos[pos] <- ifelse(length(astHaplos1) > length(astHaplos2), astHaplos[1], astHaplos[2])
      }else{  # 3-2: (A & B, C)
        
        hetHaplos[pos] <- ifelse(length(astHaplos1) > length(astHaplos2),
                                 paste0("(",paste(astHaplos1,collapse="|"),")&",astHaplos[2]),
                                 paste0("(",paste(astHaplos2,collapse="|"),")&",astHaplos[1]))
      }
      
    }else if(str_count(pat,"&") == 0){ # both are homo
      hetHaploPrt[pos] <- paste(prts,collapse = "&")
      if(astHaplos[1] == astHaplos[2]){ #1.Same homo; This happens sometimes in the transition.
        hetHaplos[pos] <- astHaplos[1] 
      }else{ #2. Regions are homo in both parents, but with diffrent haplo
        hetHaplos[pos] <- paste(astHaplos[1],astHaplos[2],sep="&")
      }
    }else{
      
    }
  }
  return(list(hetHaplos=hetHaplos,hetHaploPrt = hetHaploPrt))
}

convertPrtToAst <- function(line,prtHaplos,astHaplos,astData,allPrts,astHaploProb){
  # This function takes a line's parental calls and its parents's ancestral calls together,
  # to trace ancestral calls and prob for a give line.
  # eg. for a given bin, line1's parental call is A, and then A's ancestral haplotype is O, then line1's astCall is O;
  
  astProb <- rep(1,length(prtHaplos))
  for(haplo in unique(prtHaplos)){
    posIndex <- which(prtHaplos == haplo)
    
    # 1. handle heterogyzous cases (A&B, A&B&C,A&?, A|B&C,); no changes on the astHaplo since it is already parsed.
    if(str_detect(haplo,"&")){
      hetPrts <- unlist(strsplit(haplo,"&|\\|"))
      hetPrts <- hetPrts[hetPrts %in% colnames(astHaploProb)]
      if(length(hetPrts) > 1){
        astProb[posIndex] <- apply(astHaploProb[posIndex,hetPrts],1,mean)
      }else if(length(hetPrts) == 1){
        astProb[posIndex] <- astHaploProb[posIndex,hetPrts]
      }else{
        # no changes
      }
    }
    
    # 2. other extreme cases
    if(!haplo %in% c("Other",allPrts)){next;} # include het,& and any other haplos
    
    # 3. typical cases
    if(length(posIndex) > 0){
      if(haplo == "Other"){
        astHaplos[posIndex] <- line
      }else{
        posIndexHaplo <- as.character(astData[posIndex,haplo])
        posIndexIndex <- str_detect(posIndexHaplo,"&|_het|Heterozygous")
        if(length(posIndexIndex) > 0){
          astHaplos[posIndex[!posIndexIndex]] <- as.character(astData[posIndex[!posIndexIndex],haplo])
          astProb[posIndex[!posIndexIndex]] <- astHaploProb[posIndex[!posIndexIndex],haplo]
          astHaplos[posIndex[posIndexIndex]] <- line
          
        }else{
          astHaplos[posIndex] <- posIndexHaplo
          astProb[posIndex] <- astHaploProb[posIndex,haplo]
        }
        
      }
    }
    #print(haplo)
    #print(table(astHaplos))
  }
  return(list(astHaplos=astHaplos, astProb = astProb))
  
}

convertOtherToHaploTable <- function(lineProbDataHaplo){
  row.names(lineProbDataHaplo) <- lineProbDataHaplo$index
  haploTable <- data.frame()
  
  for (chr in unique(lineProbDataHaplo$genMapChr)){
    markerIndex <- subset(lineProbDataHaplo,genMapChr == chr)$index
    if(length(markerIndex) <= 10){next;}
    startIndex <- markerIndex[1]
    currentIndex <- markerIndex[1]
    for (i in 2:length(markerIndex)){
      if(markerIndex[i] - currentIndex != 1){
        haploTable <- rbind(haploTable,data.frame(
          chromosome = chr,
          start_index = startIndex,
          end_index = markerIndex[i - 1],
          start_pos = lineProbDataHaplo[as.character(startIndex),'genMapPos'],
          end_pos = lineProbDataHaplo[as.character(markerIndex[i-1]),'genMapPos'],
          stringsAsFactors = F
          
        ))
        startIndex <- markerIndex[i]
      }
      
      if(i == length(markerIndex)){ # last data
        haploTable <- rbind(haploTable,data.frame(
          chromosome = chr,
          start_index = startIndex,
          end_index = markerIndex[i],
          start_pos = lineProbDataHaplo[as.character(startIndex),'genMapPos'],
          end_pos = lineProbDataHaplo[as.character(markerIndex[i-1]),'genMapPos'],
          stringsAsFactors = F
        ))
      }
      currentIndex <- markerIndex[i]
    }
    
  }
  return(haploTable)
}

findLineShareOther <- function(line,otherHaploTable,lsh,allPrts,lineProbData){
  # Fill the "other" regions based on LSH
  # prt line must have prob. >= 0.1 
  
  allIndex <- as.numeric()
  haplos <- as.character()
  
  for(i in 1:nrow(otherHaploTable)){
    st <- otherHaploTable$start_index[i]
    ed <- otherHaploTable$end_index[i]
    for(index in st:ed){
      allIndex <- c(allIndex,index)
      probs <- lineProbData[index,allPrts]
      names(probs) <- allPrts
      if(all(probs <= 0.1)){haplos <- c(haplos,line);next;}
      subLsh <- lsh %>%  filter(start_index_map <= index, end_index_map >= index)
      if(nrow(subLsh) > 0){
        sharedLines <- unique(c(subLsh$line1,subLsh$line2))
        sharedLines <- sharedLines[!sharedLines == line]
        
        if(length(sharedLines) == 1){
          if(probs[sharedLines] >= 0.1){
            haplos <- c(haplos,sharedLines)
          }else{
            haplos <- c(haplos,line)
          }
          
        }else{
          sharedLineProbs <- sort(probs[sharedLines],decreasing = T)
          if(sharedLineProbs[1] >= 0.1){
            haplos <- c(haplos,names(sharedLineProbs)[1])
          }else{
            haplos <- c(haplos,line)
          }
        }
        
      }else{
        haplos <- c(haplos,line)
      }
    }
  }
  names(haplos) <- allIndex
  return(haplos)
}

getLongestFpPath <- function(line,allFpLineInfo,type,layer){
  
  allFpLinesWithPed <- allFpLineInfo$lineName
  
  maxGen <- 1
  
  # line not in the FP list is assigned value 1
  if(!line %in% allFpLinesWithPed){
    return(maxGen)
  }
  
  # lines without any FP parents is assigned value 1
  if(allFpLineInfo[line,"fpp"] == "None"){
    return(maxGen)
  }
  
  # line with longestPath calculated, assigned its values in
  if(allFpLineInfo[line,"pathLevel"] != 0){ # 0 is the initiated value. If not 0, value assigned.
    return(allFpLineInfo[line,"pathLevel"])
  }
  
  # lines with any FP parent, will recur
  if(type == "inbredDataBase"){
    peds <- pedparser(allFpLineInfo[line,"origin"])
  }else if (type == "AAAS"){
    peds <- unlist(strsplit(allFpLineInfo[line,"newParents"],";|,"))
  }
  
  if(any(peds == line)){return(1)} # ped is the line itself
  
  for(ele in peds){
    # control the number of loops
    if(layer >=20){
      return(0)
    }else{
      layer <- layer + 1
      out <- getLongestFpPath(ele,allFpLineInfo,type,layer) + 1
      maxGen <- max(out,maxGen)
    }
    
  }
  return(maxGen)
}

getAstProbTable <- function(layers_new, ancestorTable,parentalHaploData,parentalProbData,type,yyyymmdd){
  # type could be three: noLSH, LSH, noLSH_modified
  # yyyymmdd is the date
  
  layers_new <- layers_new %>% arrange(pathLevel) %>%  filter(pathLevel != 0)
  row.names(layers_new) <- layers_new$lineName
  parentalHaploLines <- layers_new$lineName
  #allPrtLines <- colnames(parentalHaploData)[2:ncol(parentalHaploData)]
  allPrtLines <- colnames(parentalHaploData)
  
  questionableLines <- as.character() # lines that has wrong pathLevel assigned
  initiatedAstLines <- as.character()
  ancestorTable <- data.frame(row.names=1:nrow(newPredictionMap))
  ancestorProbTable <- data.frame(row.names=1:nrow(newPredictionMap))
  numOfPrtHetCalls <- rep(0,nrow(layers_new))
  
  for (count in 1:nrow(layers_new)){
    qLine <- layers_new$lineName[count]
    
    
    if(!qLine %in% colnames(parentalHaploData)){next;} # line not in the parentalHaploData (parentalHaploLines); e.g RATI062-MQK-T1A1
    
    if(qLine %in% colnames(ancestorTable)){next;} # line has already been updated. 
    
    ancestorTable[,qLine] <- rep(qLine,nrow(newPredictionMap)) # initiate the value
    ancestorProbTable[,qLine] <- rep(1,nrow(newPredictionMap)) # initiate the value
    
    if(layers_new[qLine,"pathLevel"] == 1 | !qLine %in% parentalHaploLines){
      ancestorTable[,qLine] <- rep(qLine,nrow(newPredictionMap))
      ancestorProbTable[,qLine] <- rep(1,nrow(newPredictionMap)) # initiate the value
    }else{
      parentalTable <- parentalHaploData[,qLine]
      parentalProbTable <- parentalProbData[,qLine]
      parentalTableLines <- unique(parentalTable)
      parentalTableLines <- parentalTableLines[parentalTableLines != "Heterozygous"]
      parentalTableLinesPathLevel <- subset(layers_new,lineName %in% parentalTableLines & lineName != qLine)$pathLevel
      
      # lines without parentalTableLinesPathLevel; eg. "01IHI2", but hava one Fp lines;
      if(length(parentalTableLinesPathLevel) == 0){
        ancestorTable[,qLine] <- parentalTable
        ancestorProbTable[,qLine] <- parentalProbTable
        next;
      }
      
      # lines has wrong pathLevel (ancestor has larger pathLevel), save for next analysis
      if(max(parentalTableLinesPathLevel) >= layers_new[qLine,"pathLevel"]){
        questionableLines <- c(questionableLines,qLine)
        next;
      }
      
      # lines has questionable lines as ancestor, save for next analysis
      if(any(parentalTableLines %in% questionableLines)){
        questionableLines <- c(questionableLines,qLine)
        next;
      }
      
      # for any ancestor lines not in the current ancestorTable, initiate the value
      # this could initiate the qLine itself, but values will soon be replaced in the next step.
      for(line1 in parentalTableLines){
        if(!line1 %in% colnames(ancestorTable)){
          initiatedAstLines <- c(initiatedAstLines,line1)
          ancestorTable[,line1] <- rep(line1,nrow(newPredictionMap))
          ancestorProbTable[,line1] <- rep(1,nrow(newPredictionMap)) # initiate the value
        }
      }
      
      if(type == "noLSH"){
        outAstMapTable <- getAncestorProbTableFromParentsWithLSHTurnedOff(qLine,allPrtLines,ancestorTable,parentalTable,ancestorProbTable,layers_new)
        ancestorTable[,qLine] <- outAstMapTable$outAncestorHaplos
        ancestorProbTable[,qLine] <- outAstMapTable$outAncestorHaplos * parentalProbTable
        #numOfPrtHetCalls[count] <- outAstMapTable$numOfPrtHet
      }else if(type == "LSH"){
        # outAstMapTable <- getAncestorTableFromParentsWithLSH(qLine,allPrtLines,parentalTable,ancestorTable,layers_new)
        # ancestorTable[,qLine] <- outAstMapTable
      }else if(type == "noLSH_modified"){
        
      }else{
        print("Error: type is not correctly set")
      }
      
    }
    
    # Growing up the ancestor haplotype table
    #ancestorTable <- data.frame(row.names=1:nrow(newPredictionMap))
    if(count %% 1000 == 0 ){
      print(paste0("Processed ", count, " lines ",Sys.time()))
    }
    
    if(count %% 10000 == 0 | count == nrow(layers_new)){
      # saveRDS(ancestorTable,paste0("newAncestorHaploCaller/parentalTableFiles/ancestorTable_",yyyymmdd,"_",type,".rds"))
      # s3saveRDS(ancestorTable,object=paste0("tzuo/Project/AncestorHaplotypes/newAncestorHaploCaller_beta/parentalTableFiles/ancestorTable_",yyyymmdd,"_",type,".rds"),
      #           bucket= "breeding-scratch-space")
      
      # saveRDS(ancestorTable,"newAncestorHaploCaller/parentalTableFiles/ancestorTable_20200312.rds")
      # s3saveRDS(ancestorTable,object="tzuo/Project/AncestorHaplotypes/newAncestorHaploCaller_beta/parentalTableFiles/ancestorTable_20200312.rds",
      #           bucket= "breeding-scratch-space")
      
    }
    
  }
  return(ancestorProbTable)
  
}



generateAstHaploOld <- function(line,layers_new,lshData,allPBHLines,hetRegionData){
  totalBins <- 17116
  
  #if(layers_new[line,"oldPathLevel"] == 0){return(paste0(level,"_",count))}
  #if(is.na(layers_new[line,"directParents"])){return(paste0(level,"_",count))}
  #if(layers_new[line,"oldPathLevel"] == 0 | !line %in% AaaSOrigins | layers_new[line,"pathLevel"] == 1 | is.na(layers_new[line,"directParents"])){
  if(layers_new[line,"pathLevel"] <=1){ 
    prtHaplo <- rep(line,totalBins)
    prtHaplo <- assignHetOtherToHet(line,prtHaplo,hetRegionData,allPBHLines)
    saveRDS(prtHaplo,paste0("/mnt/results/PBH/parentalHaploData/prtHaploData_",line,".rds"))
    saveRDS(rep(1,totalBins),paste0("/mnt/results/PBH/parentalHaploProb/prtHaploProb_",line,".rds"))
    saveRDS(prtHaplo,paste0("/mnt/results/PBH/astHaploData/astHaploData_",line,".rds"))
    saveRDS(rep(1,totalBins),paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",line,".rds"))
  }else{
    
    # 1. pull parental prob data from Danny's parental call
    lineProbData <- getParentalProbAllbyLine(line,dominoPath,linesMissNames)
    allPrts <- sort(colnames(lineProbData)[4:(ncol(lineProbData)-1)])
    #allPrts <- sort(unlist(strsplit(layers_new[line,"Parents"],";")))
    directPrts <- sort(unlist(strsplit(layers_new[line,"directParents"],";")))
    
    # direct parents not in allPrts; Skip to next;
    if(!all(directPrts[directPrts %in% allPBHLines] %in% allPrts)){return(line)}
    
    # 2. modify parentalProb
    if(length(allPrts) > 1){
      # 3. find the maxProb, maxProbLine, etc
      lineProbData$top2Prob <- apply(lineProbData[,2:(4+length(allPrts)-1)],1,
                                     function(x){ y = sort(x,decreasing = T);x = sort(x[3:length(x)],decreasing = T);
                                     return(paste(y[1],names(y)[1],x[1],x[2],names(x)[1],names(x)[2],sep=";"))})
      
      lineProbData <- lineProbData %>% separate(top2Prob,c("maxProb","maxProbLine","maxProbPrt","secMaxProbPrt","maxProbPrtLine","secMaxProbPrtLine"),sep=";")
      lineProbData$maxProbPrt <- as.numeric(lineProbData$maxProbPrt)
      lineProbData$secMaxProbPrt <- as.numeric(lineProbData$secMaxProbPrt)
      lineProbData$maxProb <- as.numeric(lineProbData$maxProb)
      
      # 3.1 read the allPrts' ancestral haplos and ancestral haploProb
      astData <- data.frame(index = 1:totalBins)
      for(prt in allPrts){
        if(prt %in% allPBHLines){
          if(file.exists(paste0("/mnt/results/PBH/astHaploData/astHaploData_",prt,".rds"))){
            astData[,prt] <- readRDS(paste0("/mnt/results/PBH/astHaploData/astHaploData_",prt,".rds"))
          }
          
        }else{
          astData[,prt] <- rep(prt,totalBins)
        }
      }
      
      astHaploProb <- data.frame(index = 1:totalBins)
      for(prt in allPrts){
        if(prt %in% allPBHLines){
          if(file.exists(paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",prt,".rds"))){
            astHaploProb[,prt] <- readRDS(paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",prt,".rds"))
          }
          
        }else{
          astHaploProb[,prt] <- rep(1,totalBins)
        }
      }
      
      
      # 3.2 modify parentalProb
      lineProbDataNew <- bind_cols(lineProbData[,(5+length(allPrts)):ncol(lineProbData)],astData)
      
      probRes <- data.frame()
      
      # 3.2.1. keep prob>=0.9
      probRes <- bind_rows(probRes,lineProbDataNew %>% filter(maxProb >= 0.9))
      
      # 3.2.2. keep max(Prob) == "Heterozygous" & sameHaplo(directPrts)
      if(all(directPrts %in% allPBHLines) & length(directPrts) > 1){
        tmp1 <- lineProbDataNew %>% filter(maxProb < 0.9, maxProbLine == "Heterozygous")
        
        if(nrow(tmp1) > 0){
          tmp1_1 <- tmp1[,directPrts]
          numOfHaplo <- apply(tmp1_1,1,function(x){length(unique(x))})
          posIndex <- which(numOfHaplo == 1)
          tmp1[posIndex,"maxProb"] <- apply(lineProbData[tmp1[posIndex,"index"],c("Heterozygous",directPrts)],1,sum)
          higherHetPrtIndex <- apply(lineProbData[tmp1[posIndex,"index"],directPrts],1,which.max)
          tmp1[posIndex,"maxProbLine"] <- directPrts[higherHetPrtIndex]
          probRes <- bind_rows(probRes,tmp1)
          
        }
      }
      
      # 3.2.3. Sum (all direct parents or top2) >= 0.9 &  same (all parents’ haplotype or top2)
      tmp2 <- lineProbDataNew %>% filter(maxProb < 0.9, secMaxProbPrt >= 0.1, (maxProbPrt + secMaxProbPrt) >= 0.9)
      if(nrow(tmp2) > 0){
        sameHaplo <- apply(tmp2[,5:ncol(tmp2)],1,function(x){if(x[x[1]] == x[x[2]]){return(1)}else(return(0))})
        posIndex <- which(sameHaplo == 1)
        if(length(posIndex) > 0){
          tmp2$maxProb <- tmp2$maxProbPrt + tmp2$secMaxProbPrt
          probRes <- bind_rows(probRes,tmp2[posIndex,])
        }
      }
      
      # 3.2.4. set others to 1
      tmp3 <- lineProbDataNew %>% filter(maxProb < 0.9, maxProbLine == "Other" | !index %in% probRes$index )
      if(nrow(tmp3) > 0){
        tmp3$maxProb <- 1
        tmp3$maxProbLine <- "Other"
        probRes <- bind_rows(probRes,tmp3) %>% arrange(index)
      }
      
      probRes <- probRes %>% arrange(index)
      
      # 4. parse Het regions
      parsedHaploData <- parseHetRegions(line,layers_new,probRes$maxProbLine,astData,hetRegionData,allPBHLines)
      prtHaplos <- parsedHaploData$prtHaplo
      astHaplos <- parsedHaploData$astHaplo
      probRes$maxProbLine <- prtHaplos
      
      # 5. convert to ancestral haplotypes
      astHaploData <- convertPrtToAst(line,prtHaplos,astHaplos,astData,allPrts,astHaploProb)
      astHaplos <- astHaploData$astHaplo
      astProbs <- probRes$maxProb * astHaploData$astProb
      
      # 6. use LSH to fill "Others" >= 10 bins (1 cM); skip if line is not having LSH data
      if(layers_new[line,"inLSH"] == "TRUE"){
        lineProbData$haplo <- astHaplos
        lineProbData$index <- 1:totalBins
        lineProbDataHaplo <- lineProbData %>% filter(haplo == line)
        if(nrow(lineProbDataHaplo) > 0){
          otherHaploTable <- convertOtherToHaploTable(lineProbDataHaplo)
          if(nrow(otherHaploTable) > 0){
            otherHaploTable <- otherHaploTable %>% filter((end_index - start_index) >= 10)
            if(nrow(otherHaploTable) > 0){
              lsh <- lshData %>% filter((line1 == line & line2 %in% allPrts) | (line2 == line & line1 %in% allPrts)) %>% arrange(line1,line2,start_index)
              lshHaplos <- findLineShareOther(line,otherHaploTable,lsh,allPrts,lineProbData)
              # 7. convert to ancestral haplotypes; add to parental haplotypes
              if(length(lshHaplos) > 0){
                astHaplos[as.numeric(names(lshHaplos))] <- lshHaplos
                probRes$maxProbLine[as.numeric(names(lshHaplos))] <- lshHaplos
                probRes$maxProb[as.numeric(names(lshHaplos))] <- 0.9
                indexOfLine <- which(lshHaplos == line)
                probRes$maxProb[as.numeric(names(lshHaplos)[indexOfLine])] <- 1
                astHaploData2 <- convertPrtToAst(line,astHaplos,astHaplos,astData,allPrts,astHaploProb)
                astHaplos <- astHaploData2$astHaplos
                index_lsh <- which(lineProbData$haplo != astHaplos & astHaploData2$astHaplos == line)
                probRes$maxProb[index_lsh] <- 1
                astProbs <- probRes$maxProb * astHaploData2$astProb
              }
            }
          }
        }
      }
      
      
    }else{
      lineProbData$top2Prob <- apply(lineProbData[,2:(4+length(allPrts)-1)],1,
                                     function(x){ y = sort(x,decreasing = T);
                                     return(paste(y[1],names(y)[1],sep=";"))})
      lineProbData <- lineProbData %>% separate(top2Prob,c("maxProb","maxProbLine"),sep=";")
      lineProbData$maxProb <- as.numeric(lineProbData$maxProb)
      
      lowProbBinIndex <- which(lineProbData$maxProb < 0.9 & lineProbData$maxProbLine != "Heterozygous")
      if(length(lowProbBinIndex) > 0){ # convert low probability bins into "Other" and set prob. as 1.
        lineProbData[lowProbBinIndex,"maxProb"] <- 1
        lineProbData[lowProbBinIndex,"maxProbLine"] <- "Other"
      }
      
      # one of the direct parent has ancestralHaplo
      if(allPrts %in% directPrts & length(directPrts) == 2){
        hetRegions <- which(lineProbData$maxProbLine == "Heterozygous")
        numOfHetRegion <- length(hetRegions)
        if(numOfHetRegion > 0){
          astData <- data.frame(index = 1:totalBins)
          
          if(file.exists(paste0("/mnt/results/PBH/astHaploData/astHaploData_",allPrts,".rds"))){
            astData[,allPrts] <- readRDS(paste0("/mnt/results/PBH/astHaploData/astHaploData_",allPrts,".rds"))
            hetHaplos <- rep(paste0(line,"_het"),numOfHetRegion)
            hetHaploData <- parseHetRegionOneParent(hetHaplos,astData[hetRegions,allPrts],allPrts)
            lineProbData$maxProbLine[hetRegions] <- hetHaploData$hetHaplos
          }
          
        }
      }
      
      probRes <- lineProbData[,c("maxProb","maxProbLine")]
      probRes$maxProbLine[which(probRes$maxProbLine == "Heterozygous")] <- paste(line,"het",sep="_")
      astHaplos <- probRes$maxProbLine
      astProbs <- probRes$maxProb
    }
    
    
    # save the data
    parentalHaplos <- str_replace_all(probRes$maxProbLine,"Other",line)
    astHaplos <- str_replace_all(astHaplos,"Other",line)
    saveRDS(parentalHaplos,paste0("/mnt/results/PBH/parentalHaploData/prtHaploData_",line,".rds"))
    saveRDS(probRes$maxProb,paste0("/mnt/results/PBH/parentalHaploProb/prtHaploProb_",line,".rds"))
    saveRDS(astHaplos,paste0("/mnt/results/PBH/astHaploData/astHaploData_",line,".rds"))
    saveRDS(astProbs,paste0("/mnt/results/PBH/ancestralHaploProb/astHaploProb_",line,".rds"))
  }
  return(line)
  
}














